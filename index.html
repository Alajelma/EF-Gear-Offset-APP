<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Gear Offset 2050 â€“ Lernende Verzahnungs-Korrektur</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.5.3/jspdf.debug.js"></script>

<style>
:root {
  --bg: #05060a;
  --panel: #0b1024cc;
  --accent: #4fd1ff;
  --text: #eef5ff;
  --muted: #9bb2cc;
  --border: #2a3558;
  --danger: #ff4b6a;
  --ok: #32d675;
}
*{box-sizing:border-box;}
body{
  margin:0;
  background:radial-gradient(circle at top,#11172f,#05060a 60%);
  color:var(--text);
  font-family:-apple-system,system-ui,Segoe UI,sans-serif;
  padding:16px;
}
.app{
  max-width:1200px;
  margin:0 auto;
}
.card{
  background:var(--panel);
  padding:18px;
  border-radius:18px;
  margin-bottom:18px;
  border:1px solid var(--border);
  backdrop-filter:blur(16px);
}
h2{
  margin:0 0 12px 0;
  color:var(--accent);
  font-size:14px;
  text-transform:uppercase;
  letter-spacing:0.18em;
}
label{
  color:var(--muted);
  font-size:12px;
  display:block;
  margin-bottom:3px;
}
input,textarea,select{
  width:100%;
  padding:7px 10px;
  border-radius:10px;
  border:1px solid #3a4a6b;
  background:#060917cc;
  color:var(--text);
  margin-bottom:8px;
  font-size:13px;
}
button{
  padding:7px 14px;
  border-radius:14px;
  border:1px solid var(--accent);
  background:#0c1430cc;
  color:var(--text);
  font-size:11px;
  letter-spacing:0.12em;
  text-transform:uppercase;
  cursor:pointer;
}
button.secondary{
  border-color:#3a4a6b;
  background:#080d1bcc;
}
button.y-off{
  border-color:var(--danger);
  color:var(--danger);
  background:#14060acc;
}
button.y-on{
  border-color:var(--ok);
  color:var(--ok);
  background:#05150bcc;
}
button.y-active{
  box-shadow:0 0 12px rgba(50,214,117,0.6);
}
.grid-2{
  display:grid;
  grid-template-columns:1.1fr 1fr;
  gap:18px;
}
.grid-2-small{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:12px;
}
pre{
  background:#060917dd;
  padding:12px;
  border-radius:10px;
  border:1px solid var(--border);
  white-space:pre-wrap;
  font-size:12px;
}
#ocrPreview{
  max-width:100%;
  border-radius:10px;
  margin-top:10px;
  display:none;
}
.info{
  font-size:11px;
  color:var(--muted);
  margin-top:4px;
}
hr{
  border:none;
  border-top:1px solid var(--border);
  margin:10px 0;
}
</style>
</head>
<body>
<div class="app">

<!-- HEADER -->
<div style="display:flex;align-items:center;gap:14px;margin-bottom:22px;">
  <img src="logo.jpg" style="height:52px;border-radius:8px;">
  <div>
    <div style="color:var(--accent);font-size:16px;letter-spacing:0.14em;text-transform:uppercase;">Gear Offset 2050</div>
    <div style="color:var(--muted);font-size:11px;">Verzahnung â€¢ Lernende Fanuc-Korrektur â€¢ OCR â€¢ DFQ â€¢ PDF</div>
  </div>
</div>

<div class="grid-2">

<!-- LINKER BEREICH -->
<div>

  <div class="card">
    <h2>Templates</h2>

    <div class="grid-2-small">
      <div>
        <label>Template Auswahl</label>
        <select id="templateSelect"></select>
      </div>
      <div>
        <label>Name speichern</label>
        <input id="tplName" placeholder="z.B. Mahlring_0150787_M1">
      </div>
    </div>

    <div class="grid-2-small">
      <div><label>Artikel</label><input id="article_id"></div>
      <div><label>Maschine</label><input id="machine_id"></div>
    </div>

    <button class="secondary" onclick="saveTemplate()">Speichern</button>
    <button class="secondary" onclick="loadTemplate()">Laden</button>
    <button class="secondary" onclick="deleteTemplate()">LÃ¶schen</button>

    <div style="margin-top:10px;">
      <button class="secondary" onclick="exportTemplates()">Export</button>
      <button class="secondary" onclick="importTemplates()">Import</button>
    </div>

    <textarea id="tplJson" rows="3" placeholder="JSON fÃ¼r Export / Import"></textarea>
    <div class="info">
      Templates speichern Soll-/Istwerte, Artikel, Maschine.  
      Lern-Historie wird je Maschine/Artikel separat im Hintergrund gespeichert.
    </div>
  </div>

  <div class="card">
    <h2>Sollwerte & Lernen</h2>

    <div class="grid-2-small">
      <div><label>Z1 Pferch Soll</label><input id="z1P_soll"></div>
      <div><label>Z1 HÃ¼ll Soll</label><input id="z1H_soll"></div>
      <div><label>Z2 Pferch Soll</label><input id="z2P_soll"></div>
      <div><label>Z2 HÃ¼ll Soll</label><input id="z2H_soll"></div>
    </div>

    <div class="grid-2-small">
      <div><label>Z1 Position</label><input id="z1_pos"></div>
      <div><label>Z2 Position</label><input id="z2_pos"></div>
    </div>

    <label>FrÃ¤serwinkel (Grad)</label>
    <input id="winkel" value="55">

    <label style="margin-top:8px;">Y-Korrektur</label>
    <div style="display:flex;gap:8px;flex-wrap:wrap;">
      <button id="yOffBtn" class="y-off y-active" onclick="setYMode(false)">ðŸŸ¥ Y AUS (Serienmodus)</button>
      <button id="yOnBtn" class="y-on" onclick="setYMode(true)">ðŸŸ© Y EIN (Grundjustage)</button>
    </div>
    <input id="y_enable" type="hidden" value="0">

    <hr>

    <h2 style="font-size:12px;margin-top:0;">Lernen aus meiner Korrektur</h2>
    <div class="grid-2-small">
      <div><label>Meine Korrektur X (mm)</label><input id="learn_x" placeholder="z.B. +0.15"></div>
      <div><label>Meine Korrektur Y (mm)</label><input id="learn_y" placeholder="z.B. -0.15"></div>
    </div>
    <div class="grid-2-small">
      <div><label>Meine Korrektur Z (mm)</label><input id="learn_z" placeholder="z.B. -0.05"></div>
      <div></div>
    </div>

    <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:4px;">
      <button class="secondary" onclick="saveLearnStart()">Lern-Start speichern</button>
      <button class="secondary" onclick="applyLearning()">Korrektur lernen</button>
    </div>

    <div id="factorStatus" class="info"></div>
    <div class="info">
      Ablauf:  
      1) Teil 1 messen â†’ Istwerte eintragen â†’ â€žLern-Start speichernâ€œ.  
      2) Auf Maschine X/Y/Z korrigieren, Teil 2 messen, Istwerte eintragen.  
      3) Deine gemachten Offsets in die Korrektur-Felder schreiben â†’ â€žKorrektur lernenâ€œ.  
      Die App speichert Fehler â†’ Offset als Sample.  
      Die VorschlÃ¤ge werden mit Gauss-Filter aus der Historie stabil berechnet.
    </div>
  </div>

  <div class="card">
    <h2>Istwerte Â· OCR</h2>

    <div class="grid-2-small">
      <div><input id="z1P_ist" placeholder="Z1 Pferch Ist (oben)"></div>
      <div><input id="z1H_ist" placeholder="Z1 HÃ¼ll Ist (oben)"></div>
      <div><input id="z2P_ist" placeholder="Z2 Pferch Ist (unten)"></div>
      <div><input id="z2H_ist" placeholder="Z2 HÃ¼ll Ist (unten)"></div>
    </div>

    <input id="ocrFile" type="file" accept="image/*">
    <button class="secondary" onclick="runOCR()">OCR starten</button>

    <img id="ocrPreview">
    <div id="ocrStatus" class="info"></div>
    <div class="info">
      OCR liest Istwerte (UTol) in Reihenfolge: Z1P, Z1H, Z2P, Z2H.  
      Nach OCR wird automatisch eine Korrektur berechnet.
    </div>
  </div>

  <div class="card">
    <h2>DFQ Datei</h2>
    <input id="dfqFile" type="file" accept=".dfq,.txt">
    <button class="secondary" onclick="parseDFQ()">DFQ laden</button>
    <div class="info">
      K0001/1â€“4 â†’ Z1P, Z1H, Z2P, Z2H Ist.  
      Nach DFQ-Import wird automatisch eine Korrektur berechnet.
    </div>
  </div>

</div>

<!-- RECHTER BEREICH -->
<div>

  <div class="card">
    <h2>Berechnung</h2>
    <button onclick="calculate()">Berechnen</button>
    <button class="secondary" onclick="exportPDF()" style="margin-left:8px;">PDF</button>
    <pre id="result">Noch keine Berechnung</pre>
  </div>

  <div class="card">
    <h2>Fanuc Wear Vorschlag</h2>
    <pre id="fanucOut">Noch keine Daten</pre>
  </div>

</div>

</div>

<script>
/* ---------- Template Funktionen ---------- */
function refreshTemplateList(){
  templateSelect.innerHTML="";
  const keys=Object.keys(localStorage).filter(k=>k.startsWith("tpl_"));
  if(keys.length===0){
    const opt=document.createElement("option");
    opt.textContent="Kein Template";
    templateSelect.appendChild(opt);
    return;
  }
  keys.forEach(k=>{
    const d=JSON.parse(localStorage.getItem(k));
    const opt=document.createElement("option");
    opt.value=k;
    opt.textContent=(d.machine_id||"?")+" | "+(d.article_id||k.replace("tpl_",""));
    templateSelect.appendChild(opt);
  });
}
refreshTemplateList();

function saveTemplate(){
  const name=tplName.value.trim();
  if(!name){alert("Name fehlt.");return;}
  const d={
    article_id:article_id.value,
    machine_id:machine_id.value,
    z1P_soll:z1P_soll.value,
    z1H_soll:z1H_soll.value,
    z2P_soll:z2P_soll.value,
    z2H_soll:z2H_soll.value,
    z1_pos:z1_pos.value,
    z2_pos:z2_pos.value,
    winkel:winkel.value,
    y_enable:y_enable.value,
    z1P_ist:z1P_ist.value,
    z1H_ist:z1H_ist.value,
    z2P_ist:z2P_ist.value,
    z2H_ist:z2H_ist.value
  };
  localStorage.setItem("tpl_"+name,JSON.stringify(d));
  refreshTemplateList();
}

function loadTemplate(){
  const key=templateSelect.value;
  if(!key.startsWith("tpl_"))return;
  const d=JSON.parse(localStorage.getItem(key));
  Object.keys(d).forEach(k=>{
    const el=document.getElementById(k);
    if(!el) return;
    if(k==="y_enable"){
      setYMode(d[k]=="1");
    }else{
      el.value=d[k];
    }
  });
}

function deleteTemplate(){
  const key=templateSelect.value;
  if(key.startsWith("tpl_")){
    localStorage.removeItem(key);
    refreshTemplateList();
  }
}

function exportTemplates(){
  const all={};
  Object.keys(localStorage).forEach(k=>{
    if(k.startsWith("tpl_")){
      all[k.replace("tpl_","")] = JSON.parse(localStorage.getItem(k));
    }
  });
  tplJson.value=JSON.stringify(all,null,2);
}

function importTemplates(){
  try{
    const obj=JSON.parse(tplJson.value);
    Object.keys(obj).forEach(k=>{
      localStorage.setItem("tpl_"+k,JSON.stringify(obj[k]));
    });
    refreshTemplateList();
    alert("Templates importiert");
  }catch(e){
    alert("Import Fehler: "+e);
  }
}

/* ---------- Modell / Historie pro Maschine/Artikel ---------- */
function getModelKey(){
  const m=(machine_id.value||"").trim();
  const a=(article_id.value||"").trim();
  if(!m && !a) return "global";
  return m+"|"+a;
}
function loadSamples(key){
  try{
    const s=localStorage.getItem("samples_"+key);
    if(!s) return [];
    return JSON.parse(s);
  }catch(e){return [];}
}
function saveSamples(key,arr){
  if(arr.length>200) arr=arr.slice(arr.length-200);
  localStorage.setItem("samples_"+key,JSON.stringify(arr));
}

/* ---------- Y-Modus ---------- */
function setYMode(on){
  const offBtn=document.getElementById("yOffBtn");
  const onBtn=document.getElementById("yOnBtn");
  const yVal=document.getElementById("y_enable");

  if(on){
    yVal.value="1";
    onBtn.classList.add("y-active");
    offBtn.classList.remove("y-active");
  }else{
    yVal.value="0";
    offBtn.classList.add("y-active");
    onBtn.classList.remove("y-active");
  }
}
setYMode(false);

/* ---------- OCR ---------- */
async function runOCR(){
  const file=ocrFile.files[0];
  if(!file){alert("Bild wÃ¤hlen.");return;}
  ocrStatus.textContent="OCR lÃ¤uft...";

  const reader=new FileReader();
  reader.onload=async()=>{
    ocrPreview.src=reader.result;
    ocrPreview.style.display="block";

    const {data:{text}} = await Tesseract.recognize(reader.result,'deu');
    parseOCR(text);
    ocrStatus.textContent="OCR abgeschlossen";
    calculate(); // direkt Vorschlag berechnen
  };
  reader.readAsDataURL(file);
}

function parseOCR(text){
  const lines=text.split(/\r?\n/).map(l=>l.trim());
  const rel=lines.filter(l=>/(GX|GN)/i.test(l));
  const out=[];
  rel.forEach(l=>{
    const nums=[...l.matchAll(/(\d{1,2}\.\d{3})/g)];
    if(nums.length>=3){
      out.push(parseFloat(nums[2][1])); // UTol = 3. Zahl
    }
  });
  if(out.length<4){
    alert("OCR unvollstÃ¤ndig: "+out.join(", "));
    return;
  }
  z1P_ist.value=out[0].toFixed(3);
  z1H_ist.value=out[1].toFixed(3);
  z2P_ist.value=out[2].toFixed(3);
  z2H_ist.value=out[3].toFixed(3);
}

/* ---------- DFQ ---------- */
function parseDFQ(){
  const file=dfqFile.files[0];
  if(!file){alert("DFQ wÃ¤hlen.");return;}
  const reader=new FileReader();
  reader.onload=()=>{
    const lines=reader.result.split(/\r?\n/);
    const v={};
    lines.forEach(l=>{
      const m=l.match(/K0001\/(\d+)\s+([\d\.]+)/);
      if(m){v[m[1]]=parseFloat(m[2]);}
    });
    if(v["1"]) z1P_ist.value=v["1"].toFixed(3);
    if(v["2"]) z1H_ist.value=v["2"].toFixed(3);
    if(v["3"]) z2P_ist.value=v["3"].toFixed(3);
    if(v["4"]) z2H_ist.value=v["4"].toFixed(3);
    calculate(); // direkt Vorschlag berechnen
  };
  reader.readAsText(file);
}

/* ---------- Lernen ---------- */
let learnStart=null;

function saveLearnStart(){
  const F=id=>parseFloat(document.getElementById(id).value);
  learnStart={
    z1Ps:F("z1P_soll"),
    z1Hs:F("z1H_soll"),
    z2Ps:F("z2P_soll"),
    z2Hs:F("z2H_soll"),
    z1Pi:F("z1P_ist"),
    z1Hi:F("z1H_ist"),
    z2Pi:F("z2P_ist"),
    z2Hi:F("z2H_ist")
  };
  factorStatus.textContent="Lern-Start gespeichert (Teil 1).";
}

function applyLearning(){
  if(!learnStart){
    factorStatus.textContent="Bitte zuerst â€žLern-Start speichernâ€œ drÃ¼cken.";
    return;
  }
  const lx=parseFloat(learn_x.value)||0;
  const ly=parseFloat(learn_y.value)||0;
  const lz=parseFloat(learn_z.value)||0;

  const s=learnStart;

  const D1s=(s.z1Ps+s.z1Hs)/2;
  const D2s=(s.z2Ps+s.z2Hs)/2;
  const D1i=(s.z1Pi+s.z1Hi)/2;
  const D2i=(s.z2Pi+s.z2Hi)/2;

  const dD1=D1i-D1s;
  const dD2=D2i-D2s;
  const dMean=(dD1+dD2)/2;
  const dDiff=dD2-dD1;

  const pair2Ist=s.z2Hi-s.z2Pi;
  const pair2Soll=s.z2Hs-s.z2Ps;
  const dPair=pair2Ist-pair2Soll;

  const key=getModelKey();
  let samples=loadSamples(key);
  samples.push({
    dMean:dMean,
    dDiff:dDiff,
    dPair:dPair,
    offX:lx,
    offY:ly,
    offZ:lz
  });
  saveSamples(key,samples);

  factorStatus.textContent="Korrektur als Lern-Sample gespeichert (Historie aktualisiert).";
}

/* ---------- Gauss-gewichtete Steigung pro Achse ---------- */
function gaussGain(samples, curMean, curDiff, curPair, axis){
  if(samples.length===0) return null;

  const sigmaMean=0.05; // 0.05 mm
  const sigmaDiff=0.05;
  const sigmaPair=0.05;
  const invM=1/(sigmaMean*sigmaMean);
  const invD=1/(sigmaDiff*sigmaDiff);
  const invP=1/(sigmaPair*sigmaPair);

  let sum_wx2=0, sum_wxy=0;

  for(const s of samples){
    const dM=curMean - (s.dMean||0);
    const dD=curDiff - (s.dDiff||0);
    const dP=curPair - (s.dPair||0);
    const dist2 = dM*dM*invM + dD*dD*invD + dP*dP*invP;
    const w = Math.exp(-0.5*dist2); // Gauss-Gewicht

    let x, y;
    if(axis==="X"){
      x = s.dMean||0;
      y = s.offX||0;
    }else if(axis==="Z"){
      x = s.dDiff||0;
      y = s.offZ||0;
    }else{
      x = s.dPair||0;
      y = s.offY||0;
    }

    sum_wx2 += w * x * x;
    sum_wxy += w * x * y;
  }

  const eps=1e-6;
  if(Math.abs(sum_wx2)<eps) return null;
  return sum_wxy / sum_wx2;
}

/* ---------- Berechnung ---------- */
function calculate(){
  const F=id=>parseFloat(document.getElementById(id).value);

  const z1Ps=F("z1P_soll"), z1Hs=F("z1H_soll");
  const z2Ps=F("z2P_soll"), z2Hs=F("z2H_soll");
  const z1Pi=F("z1P_ist"), z1Hi=F("z1H_ist");
  const z2Pi=F("z2P_ist"), z2Hi=F("z2H_ist");

  const all=[z1Ps,z1Hs,z2Ps,z2Hs,z1Pi,z1Hi,z2Pi,z2Hi];
  if(all.some(v=>isNaN(v))){
    result.textContent="Bitte alle Soll- und Istwerte eingeben.";
    fanucOut.textContent="Keine VorschlÃ¤ge â€“ Werte unvollstÃ¤ndig.";
    return;
  }

  const W=F("winkel");
  const rad=W*Math.PI/180;

  const D1s=(z1Ps+z1Hs)/2, D2s=(z2Ps+z2Hs)/2;
  const D1i=(z1Pi+z1Hi)/2, D2i=(z2Pi+z2Hi)/2;

  const dD1=D1i-D1s;
  const dD2=D2i-D2s;

  const dMean=(dD1+dD2)/2;
  const dDiff=dD2-dD1;

  const pair2Ist=z2Hi-z2Pi;
  const pair2Soll=z2Hs-z2Ps;
  const dPair=pair2Ist-pair2Soll;

  const yEnabled=(document.getElementById("y_enable").value==="1");

  const key=getModelKey();
  const samples=loadSamples(key);

  let offX, offY, offZ;

  if(samples.length>0){
    const fx=gaussGain(samples,dMean,dDiff,dPair,"X");
    const fz=gaussGain(samples,dMean,dDiff,dPair,"Z");
    const fy=gaussGain(samples,dMean,dDiff,dPair,"Y");

    if(fx!==null){
      offX=fx*dMean;
    }else{
      offX=(dMean/2); // Startlogik
    }

    if(fz!==null){
      offZ=fz*dDiff;
    }else{
      const tanw=Math.tan(rad);
      offZ = Math.abs(tanw)>1e-6 ? -(dDiff/(2*tanw)) : 0;
    }

    if(yEnabled){
      if(fy!==null){
        offY=fy*dPair;
      }else{
        offY=-(dPair/2);
      }
    }else{
      offY=0;
    }
  }else{
    // Noch keine Historie â†’ reine Geometrie
    offX=(dMean/2);
    const tanw=Math.tan(rad);
    offZ = Math.abs(tanw)>1e-6 ? -(dDiff/(2*tanw)) : 0;
    offY = yEnabled ? -(dPair/2) : 0;
  }

  // auf Hundertstel runden und kleine Werte abtÃ¶ten
  const round01=v=>Math.round(v*100)/100;
  const dead=0.005; // unter 0.005 mm â†’ 0
  function clean(v){
    v=round01(v);
    if(Math.abs(v)<dead) return 0;
    return v;
  }

  offX=clean(offX);
  offY=clean(offY);
  offZ=clean(offZ);

  // Vorschlag direkt in Korrektur-Felder schreiben
  learn_x.value = offX.toFixed(2);
  learn_y.value = offY.toFixed(2);
  learn_z.value = offZ.toFixed(2);

  const res=
    "Î”D1 (Mitte Z1): "+dD1.toFixed(3)+" mm\n"+
    "Î”D2 (Mitte Z2): "+dD2.toFixed(3)+" mm\n"+
    "Î”Dmean: "+dMean.toFixed(3)+" mm\n"+
    "Î”Diff (Z2-Z1): "+dDiff.toFixed(3)+" mm\n"+
    "Î”Pair2 (HÃ¼ll-Pferch Z2): "+dPair.toFixed(3)+" mm\n"+
    "\nVorgeschlagene Offsets (Hundertstel, Gauss-gefiltert):\n"+
    "X: "+offX.toFixed(2)+" mm\n"+
    "Z: "+offZ.toFixed(2)+" mm\n"+
    "Y: "+offY.toFixed(2)+" mm";

  result.textContent=res;

  fanucOut.textContent=
    "FANUC WEAR (Vorschlag)\n"+
    "X: "+offX.toFixed(2)+" mm\n"+
    "Z: "+offZ.toFixed(2)+" mm\n"+
    "Y: "+offY.toFixed(2)+" mm";
}

/* ---------- PDF Export ---------- */
function exportPDF(){
  var doc=new jsPDF();

  doc.setFont("helvetica","bold");
  doc.setFontSize(16);
  doc.text("Gear Offset â€“ Messbericht",10,15);

  doc.setFont("helvetica","normal");
  doc.setFontSize(10);
  doc.text("Datum: "+new Date().toLocaleString(),10,22);
  if(article_id.value) doc.text("Artikel: "+article_id.value,10,28);
  if(machine_id.value) doc.text("Maschine: "+machine_id.value,10,34);

  doc.setFont("helvetica","bold");
  doc.setFontSize(12);
  doc.text("Soll / Ist",10,44);
  doc.line(10,46,200,46);

  let y=52;
  const row=(a,b,c)=>{
    doc.text(a.padEnd(12)+" "+(b||"-")+"  "+(c||"-"),10,y);
    y+=6;
  };
  row("Z1 Pferch",z1P_soll.value,z1P_ist.value);
  row("Z1 HÃ¼ll",z1H_soll.value,z1H_ist.value);
  row("Z2 Pferch",z2P_soll.value,z2P_ist.value);
  row("Z2 HÃ¼ll",z2H_soll.value,z2H_ist.value);

  doc.setFont("helvetica","bold");
  doc.setFontSize(12);
  doc.text("Berechnung / Offsets",10,y+6);
  doc.line(10,y+8,200,y+8);
  y+=14;

  doc.setFont("courier","normal");
  result.textContent.split("\n").forEach(l=>{
    doc.text(l,10,y); y+=6;
  });

  doc.save("gear-offset-report.pdf");
}
</script>

</body>
</html>
